(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{915:function(e,t,r){"use strict";r.r(t);var s=r(12),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("blockquote",[r("p",[e._v("以下两篇文章都讲的很到位，建议细品")])]),e._v(" "),r("ol",[r("li",[r("a",{attrs:{href:"https://zhaohuabing.com/post/2020-03-19-pki/",target:"_blank",rel:"noopener noreferrer"}},[e._v("数字证书原理-赵化冰的博客 | Zhaohuabing Blog"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://zhaohuabing.com/post/2020-05-19-k8s-certificate/",target:"_blank",rel:"noopener noreferrer"}},[e._v("一文带你彻底厘清 Kubernetes 中的证书工作机制-赵化冰的博客 | Zhaohuabing Blog"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("CN 字段，对于 SSL 证书，一般为网站域名；而对于代码签名证书则为申请单位名称；而对于客户端证书则为证书申请者的姓名；")]),e._v(" "),r("p",[e._v("简称：O 字段，对于 SSL 证书，一般为网站域名；而对于代码签名证书则为申请单位名称；而对于客户端单位证书则为证书申请者所在单位名称；")]),e._v(" "),r("p",[e._v("所在城市 (Locality)| 简称：L 字段\n所在省份 (State/Provice)| 简称：ST 字段\n所在国家 (Country)| 简称：C 字段，只能是国家字母缩写，如中国：CN")]),e._v(" "),r("h2",{attrs:{id:"证书中的-hosts"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#证书中的-hosts"}},[e._v("#")]),e._v(" 证书中的 hosts")]),e._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://github.com/opsnull/follow-me-install-kubernetes-cluster/issues/185",target:"_blank",rel:"noopener noreferrer"}},[e._v("kube-apiserver 证书中的 hosts 受限问题 · Issue #185 · opsnull/follow-me-install-kubernetes-cluster · GitHub"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("我简单的把证书分为三类：")]),e._v(" "),r("ul",[r("li",[e._v("server 证书：server auth；")]),e._v(" "),r("li",[e._v("client 证书：client auth；")]),e._v(" "),r("li",[e._v("peer 证书：server auth + client auth。")])]),e._v(" "),r("p",[e._v("经过我的实践和理解：client 证书可以不用指定 "),r("code",[e._v("hosts")]),e._v(" 字段，server 证书和 peer 证书必须要指定 "),r("code",[e._v("hosts")]),e._v(" 字段，否则客户端访问时会提示错误：")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Unable to connect to the server: x509: cannot validate certificate for 192.168.1.x because it doesn't contain any IP SANs\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br")])]),r("p",[e._v("确实有这个问题，用 go 试了下，hosts 必须包含服务的地址不然就会出问题")]),e._v(" "),r("p",[e._v("但是当我在做 HA master （我使用 Keepalived 新增了一个 VIP，并且使用 HAProxy 代理 https 的 kube-apiserver）时，就会存在一个问题：由于 VIP 并不在 kube-apiserver 的 "),r("code",[e._v("hosts")]),e._v(" 中，导致所有客户端都没有办法通过 VIP 来访问 kube-apiserver （提示 VIP 不在 SANS 中）。")]),e._v(" "),r("h2",{attrs:{id:"golang-自签证书实现-https"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#golang-自签证书实现-https"}},[e._v("#")]),e._v(" golang 自签证书实现 https")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://toscode.gitee.com/huy_admin/Go-HTTPS-Demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("Go HTTPS Demo: golang 生成https 自签名证书，及服务端、客户端双向认证代码"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);