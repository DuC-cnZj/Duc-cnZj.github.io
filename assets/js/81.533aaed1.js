(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{852:function(e,n,t){"use strict";t.r(n);var l=t(13),o=Object(l.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("事务与锁是不同的。事务具有ACID（\n原子性、一致性、隔离性和持久性），锁是用于解决隔离性的一种机制。事务的隔离级别通过锁的机制来实现。另外锁有不同的粒度，同时事务也是有不同的隔离级别的（一般有四种：读未提交Read uncommitted，\n读已提交Read committed，\n可重复读Repeatable read，\n可串行化Serializable）。\n在具体的程序设计中，开启事务其实是要数据库支持才行的，如果数据库本身不支持事务，那么仍然无法确保你在程序中使用的事务是有效的。\n锁可以分为乐观锁和悲观锁：\n悲观锁：认为在修改数据库数据的这段时间里存在着也想修改此数据的事务；\n乐观锁：认为在短暂的时间里不会有事务来修改此数据库的数据；\n我们一般意义上讲的锁其实是指悲观锁，在数据处理过程中，将数据置于锁定状态（由数据库实现）。\n回到你的问题，如果开启了事务，在事务没提交之前，别人是无法修改该数据的；如果rollback，你在本次事务中的修改将撤消（不是别人修改的会没有，因为别人此时无法修改）。当然，前提是你使用的数据库支持事务。还有一个要注意的是，部分数据库支持自定义SQL锁覆盖事务隔离级别默认的锁机制，如果使用了自定义的锁，那就另当别论。\n重点：一般事务使用的是悲观锁（具有排他性）。")])]),e._v(" "),t("blockquote",[t("p",[e._v("数据库操作具有四个特性：原子性，隔离性，持久性，一致性。当多个线程操作同一个数据的时候根据不同线程或者事务的动作和时机的不同会出现不同的并发问题，比如脏读，不可重读，幻读，丢失更新等。")]),e._v(" "),t("p",[e._v("数据库事务就是具有上述四个特性的一种数据库操作逻辑，而解决不同事务的并发问题的时候就需要根据上述不同的问题设置不同的隔离级别，而不同的隔离级别底层用的就是不同的数据库锁机制，比如行锁，表锁，页锁，悲观锁，乐观锁等")])]),e._v(" "),t("p",[e._v("我的理解：锁是事务的一部分，在隔离级别上体现出来，不同的隔离级别用不同的锁，事务默认自带悲观锁")])])}),[],!1,null,null,null);n.default=o.exports}}]);